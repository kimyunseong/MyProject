#include "StdAfx.h"

HANDLE g_EngineHandle;
HANDLE g_InjectionHandle;


UINT32 g_StreamIdV4;
UINT32 g_StreamIdV6;


DRIVER_INITIALIZE DriverEntry;
EVT_WDF_DRIVER_UNLOAD MiniWfpDriverUnload;

NTSTATUS MiniWfpStreamNotify(
	FWPS_CALLOUT_NOTIFY_TYPE NotifyType,
	const GUID* FilterKey,
	const FWPS_FILTER* Filter
)
{
	UNREFERENCED_PARAMETER(NotifyType);
	UNREFERENCED_PARAMETER(FilterKey);
	UNREFERENCED_PARAMETER(Filter);

	return STATUS_SUCCESS;
}

VOID MiniWfpStreamContextCleanup(
	UINT16 LayerId,
	UINT32 CalloutId,
	UINT64 FlowContext
)
{
	UNREFERENCED_PARAMETER(LayerId);
	UNREFERENCED_PARAMETER(CalloutId);

	if (FlowContext != 0) {

		// Free the memory for the flow context structure
	}
}

NTSTATUS MiniWfpAleFlowEstablishedNotify(
	FWPS_CALLOUT_NOTIFY_TYPE NotifyType,
	const GUID* FilterKey,
	const FWPS_FILTER* Filter
)
{
	UNREFERENCED_PARAMETER(NotifyType);
	UNREFERENCED_PARAMETER(FilterKey);
	UNREFERENCED_PARAMETER(Filter);

	return STATUS_SUCCESS;
}

_IRQL_requires_min_(PASSIVE_LEVEL)
_IRQL_requires_max_(PASSIVE_LEVEL)
_IRQL_requires_same_
_Function_class_(EVT_WDF_OBJECT_CONTEXT_CLEANUP)
VOID EventCleanupDriverObject(_In_ WDFOBJECT DriverObject)
{
	UNREFERENCED_PARAMETER(DriverObject);
}

NTSTATUS MiniWfpInitDriverObjects(
	_Inout_ PDRIVER_OBJECT DriverObject,
	const PUNICODE_STRING RegistryPath,
	_Out_ WDFDRIVER* pWDFDriver,
	_Out_ WDFDEVICE* pWDFDevice
)
{
	NTSTATUS Status;
	WDF_DRIVER_CONFIG WDFConfig;
	PWDFDEVICE_INIT WDFDevInit = NULL;
	WDF_OBJECT_ATTRIBUTES WDFAttributes;

	WDF_DRIVER_CONFIG_INIT(&WDFConfig, WDF_NO_EVENT_CALLBACK);

	WDFConfig.DriverInitFlags |= WdfDriverInitNonPnpDriver;
	WDFConfig.EvtDriverUnload = MiniWfpDriverUnload;

	WDF_OBJECT_ATTRIBUTES_INIT(&WDFAttributes);
	WDFAttributes.EvtCleanupCallback = EventCleanupDriverObject;

	__try {
		Status = WdfDriverCreate(DriverObject, RegistryPath, &WDFAttributes, &WDFConfig, pWDFDriver);

		if (!NT_SUCCESS(Status))
		{
			__leave;
		}

		WDFDevInit = WdfControlDeviceInitAllocate(*pWDFDriver, &SDDL_DEVOBJ_KERNEL_ONLY);

		if (!WDFDevInit)
		{
			Status = STATUS_INSUFFICIENT_RESOURCES;
			__leave;
		}

		WdfDeviceInitSetCharacteristics(WDFDevInit, FILE_AUTOGENERATED_DEVICE_NAME, TRUE);
		WdfDeviceInitSetDeviceType(WDFDevInit, FILE_DEVICE_NETWORK);
		WdfDeviceInitSetCharacteristics(WDFDevInit, FILE_DEVICE_SECURE_OPEN, TRUE);
		Status = WdfDeviceCreate(&WDFDevInit, &WDFAttributes, pWDFDevice);

		if (!NT_SUCCESS(Status))
		{
			WdfDeviceInitFree(WDFDevInit);
			__leave;
		}

		WdfControlFinishInitializing(*pWDFDevice);
	}
	__finally {}

	return Status;
}

NTSTATUS MiniWfpRegCalloutForLayer(
	const GUID* LayerKey,
	const GUID* CalloutKey,
	_Inout_ PVOID DeviceObject,
	_Out_ UINT32* CalloutId
)
{
	NTSTATUS Status = STATUS_SUCCESS;
	FWPM_FILTER FwpmFilter = { 0 };
	FWPM_FILTER_CONDITION* FwpmFltCondi = NULL;
	FWPM_CALLOUT FwpmCallout = { 0 };
	FWPM_DISPLAY_DATA FwpmDispData = { 0 };
	BOOL bCalloutReg = FALSE;
	FWPS_CALLOUT FwpsCallout = { 0 };
	FWP_RANGE0* PortRange = NULL;
	PPORT_RANGE pPortRange;
	INT i = 0;
	FwpsCallout.calloutKey = *CalloutKey;
	//FwpsCallout.classifyFn = ;
	//FwpsCallout.notifyFn = ;

	__try {

		Status = FwpsCalloutRegister(DeviceObject, &FwpsCallout, CalloutId);
		if (!NT_SUCCESS(Status)) {

			__leave;
		}

		bCalloutReg = TRUE;
		FwpmDispData.name = L"PsNe ALE Flow Established Callout";
		FwpmDispData.description = L"Callout that gets the process path from a TCP stream";

		FwpmCallout.calloutKey = *CalloutKey;
		FwpmCallout.displayData = FwpmDispData;
		FwpmCallout.applicableLayer = *LayerKey;

		Status = FwpmCalloutAdd(g_EngineHandle, &FwpmCallout, NULL, NULL);
		if (!NT_SUCCESS(Status)) {

			__leave;
		}

		FwpmFltCondi = (FWPM_FILTER_CONDITION*)MyAllocNonPagedPool(sizeof(FWPM_FILTER_CONDITION), &g_NonPagedPoolCnt);
		if (FwpmFltCondi == NULL) {

			__leave;
		}

		memset(FwpmFltCondi, 0, sizeof(FWPM_FILTER_CONDITION));

		PortRange = MyAllocNonPagedPool(sizeof(FWP_RANGE0), &g_NonPagedPoolCnt);
		if (PortRange == NULL) {

			__leave;
		}

		memset(PortRange, 0, sizeof(FWP_RANGE0));

		FwpmFilter.layerKey = *LayerKey;
		//FwpmFilter.displayData.name = ;
		FwpmFilter.displayData.description = L"Filter that gets the process path from a TCP stream";

		FwpmFilter.action.type = FWP_ACTION_CALLOUT_INSPECTION;
		FwpmFilter.action.calloutKey = *CalloutKey;
		FwpmFilter.filterCondition = FwpmFltCondi;
		FwpmFilter.numFilterConditions = 1;
		FwpmFilter.subLayerKey = FWPM_SUBLAYER_UNIVERSAL;
		FwpmFilter.weight.type = FWP_EMPTY; // auto-weight.
/*
		for (pPortRange = g_FirstPort; pPortRange; pPortRange = pPortRange->NextPortRange) {

			PortRange[i].valueHigh.type = FWP_UINT16;
			PortRange[i].valueHigh.uint16 = (UINT16)pPortRange->PortTo;
			PortRange[i].valueLow.type = FWP_UINT16;
			PortRange[i].valueLow.uint16 = (UINT16)pPortRange->PortFrom;

			if (PortRange[i].valueHigh.uint16 == 0) {
				PortRange[i].valueHigh.uint16 = (UINT16)pPortRange->PortFrom;
			}

			FwpmFltCondi[i].matchType = FWP_MATCH_RANGE;
			FwpmFltCondi[i].conditionValue.type = FWP_RANGE_TYPE;
			FwpmFltCondi[i].fieldKey = FWPM_CONDITION_IP_REMOTE_PORT; //FWPM_CONDITION_IP_REMOTE_ADDRESS
			FwpmFltCondi[i].conditionValue.rangeValue = &PortRange[i];

			i++;
		}
*/
		Status = FwpmFilterAdd(g_EngineHandle, &FwpmFilter, NULL, NULL);
		if (!NT_SUCCESS(Status)) {

			DbgPrint("[TEST] Status=0x%X", Status);
			__leave;
		}
	}
	__finally {

		if (!NT_SUCCESS(Status)) {

			if (bCalloutReg) {

				FwpsCalloutUnregisterById(*CalloutId);
			}
		}

		if (FwpmFltCondi) {

			MyFreeNonPagedPool(FwpmFltCondi, &g_NonPagedPoolCnt);
		}

		if (PortRange) {

			MyFreeNonPagedPool(PortRange, &g_NonPagedPoolCnt);
		}
	}

	return Status;
}

NTSTATUS MiniWfpRegCallout(
	_Inout_ PVOID DeviceObject
)
{
	NTSTATUS Status = STATUS_SUCCESS;
	BOOL EngineOpened = FALSE;
	BOOL InTransaction = FALSE;
	FWPM_SESSION FwpmSession = { 0 };
	FwpmSession.flags = FWPM_SESSION_FLAG_DYNAMIC;

	__try {

		Status = FwpmEngineOpen(NULL, RPC_C_AUTHN_WINNT, NULL, &FwpmSession, &g_EngineHandle);
		if (!NT_SUCCESS(Status)) {

			__leave;
		}
		EngineOpened = TRUE;
		Status = FwpmTransactionBegin(g_EngineHandle, 0);
		if (!NT_SUCCESS(Status)) {

			__leave;
		}

		InTransaction = TRUE;
		Status = FwpmTransactionCommit(g_EngineHandle);
		if (!NT_SUCCESS(Status)) {

			__leave;
		}

		InTransaction = FALSE;
	}
	__finally {

		if (!NT_SUCCESS(Status)) {

			if (InTransaction) {

				NTSTATUS AbortStatus;
				AbortStatus = FwpmTransactionAbort(g_EngineHandle);
				_Analysis_assume_(NT_SUCCESS(AbortStatus));
			}

			if (EngineOpened) {

				FwpmEngineClose(g_EngineHandle);
				g_EngineHandle = NULL;
			}
		}
	}

	return Status;
}

void MiniWfpUnRegCallout()
{
	FwpmEngineClose(g_EngineHandle);
	g_EngineHandle = NULL;
}

_Function_class_(DRIVER_INITIALIZE)
_IRQL_requires_same_
NTSTATUS DriverEntry(
	_In_ PDRIVER_OBJECT DriverObject,
	_In_ PUNICODE_STRING RegistryPath
)
{
	NTSTATUS Status;
	WDFDEVICE WDFDevice;
	WDFDRIVER WDFDriver;
	WDFKEY ConfigKey;
	// Request NX Non-Paged Pool when available
	ExInitializeDriverRuntime(DrvRtPoolNxOptIn);

	__try {
		Status = MiniWfpInitDriverObjects(DriverObject, RegistryPath, &WDFDriver, &WDFDevice);
		if (!NT_SUCCESS(Status)) __leave;

		

	}
	__finally {}


	return Status;
}

_Function_class_(EVT_WDF_DRIVER_UNLOAD)
_IRQL_requires_same_
_IRQL_requires_max_(PASSIVE_LEVEL)
VOID MiniWfpDriverUnload(
	_In_ WDFDRIVER DriverObject
)
{
	UNREFERENCED_PARAMETER(DriverObject);

	DbgPrint("[MiniWFP] Unload Success");
}