#include "StdAfx.h"

#define INITGUID
#include <guiddef.h>

// Callout driver keys
// {C1C71375-96F3-4391-BA8D-30BD8FA014BF}
DEFINE_GUID(MINI_WPF_STREAM_DATA_V4,
	0xc1c71375, 0x96f3, 0x4391, 0xba, 0x8d, 0x30, 0xbd, 0x8f, 0xa0, 0x14, 0xbf);

// {FF5F83EE-127B-43ED-943C-FF6DC339314B}
DEFINE_GUID(MINI_WPF_STREAM_DATA_V6,
	0xff5f83ee, 0x127b, 0x43ed, 0x94, 0x3c, 0xff, 0x6d, 0xc3, 0x39, 0x31, 0x4b);

// {335B5544-3E15-488F-A4BB-8EC7C47B5842}
DEFINE_GUID(MINI_WPF_ALE_FLOW_ESTABLISHED_V4,
	0x335b5544, 0x3e15, 0x488f, 0xa4, 0xbb, 0x8e, 0xc7, 0xc4, 0x7b, 0x58, 0x42);

// {FA5654AA-55A4-4AC6-B8D1-8A039DD160AD}
DEFINE_GUID(MINI_WPF_ALE_FLOW_ESTABLISHED_V6,
	0xfa5654aa, 0x55a4, 0x4ac6, 0xb8, 0xd1, 0x8a, 0x3, 0x9d, 0xd1, 0x60, 0xad);

HANDLE g_EngineHandle;
UINT32 g_StreamIdV4;
UINT32 g_StreamIdV6;


DRIVER_INITIALIZE DriverEntry;
EVT_WDF_DRIVER_UNLOAD MiniWpfDriverUnload;

NTSTATUS MiniWPFDataStreamNotify(
	FWPS_CALLOUT_NOTIFY_TYPE NotifyType,
	const GUID* FilterKey,
	const FWPS_FILTER* Filter
)
{
	UNREFERENCED_PARAMETER(NotifyType);
	UNREFERENCED_PARAMETER(FilterKey);
	UNREFERENCED_PARAMETER(Filter);

	return STATUS_SUCCESS;
}

VOID MiniWpfStreamContextCleanup(
	UINT16 LayerId,
	UINT32 CalloutId,
	UINT64 FlowContext
)
{
	UNREFERENCED_PARAMETER(LayerId);
	UNREFERENCED_PARAMETER(CalloutId);

	if (FlowContext != 0) {

		// Free the memory for the flow context structure
	}
}

NTSTATUS MiniWpfAleFlowEstablishedNotify(
	FWPS_CALLOUT_NOTIFY_TYPE NotifyType,
	const GUID* FilterKey,
	const FWPS_FILTER* Filter
)
{
	UNREFERENCED_PARAMETER(NotifyType);
	UNREFERENCED_PARAMETER(FilterKey);
	UNREFERENCED_PARAMETER(Filter);

	return STATUS_SUCCESS;
}

NTSTATUS MiniWpfInitDriverObjects(
	_Inout_ PDRIVER_OBJECT DriverObject,
	const PUNICODE_STRING RegistryPath,
	_Out_ WDFDRIVER* pWDFDriver,
	_Out_ WDFDEVICE* pWDFDevice
)
{
	NTSTATUS Status;
	WDF_DRIVER_CONFIG WDFConfig;
	PWDFDEVICE_INIT WDFDevInit = NULL;

	WDF_DRIVER_CONFIG_INIT(&WDFConfig, WDF_NO_EVENT_CALLBACK);

	WDFConfig.DriverInitFlags |= WdfDriverInitNonPnpDriver;
	WDFConfig.EvtDriverUnload = MiniWpfDriverUnload;

	__try {
		Status = WdfDriverCreate(DriverObject, RegistryPath, WDF_NO_OBJECT_ATTRIBUTES, &WDFConfig, pWDFDriver);

		if (!NT_SUCCESS(Status))
		{
			__leave;
		}

		WDFDevInit = WdfControlDeviceInitAllocate(*pWDFDriver, &SDDL_DEVOBJ_KERNEL_ONLY);

		if (!WDFDevInit)
		{
			Status = STATUS_INSUFFICIENT_RESOURCES;
			__leave;
		}

		WdfDeviceInitSetCharacteristics(WDFDevInit, FILE_AUTOGENERATED_DEVICE_NAME, TRUE);
		WdfDeviceInitSetDeviceType(WDFDevInit, FILE_DEVICE_NETWORK);
		WdfDeviceInitSetCharacteristics(WDFDevInit, FILE_DEVICE_SECURE_OPEN, TRUE);
		Status = WdfDeviceCreate(&WDFDevInit, WDF_NO_OBJECT_ATTRIBUTES, pWDFDevice);

		if (!NT_SUCCESS(Status))
		{
			WdfDeviceInitFree(WDFDevInit);
			__leave;
		}

		WdfControlFinishInitializing(*pWDFDevice);
	}
	__finally {}

	return Status;
}

NTSTATUS MiniWpfRegCallOutForLayer(
	const GUID* LayerKey,
	const GUID* CalloutKey,
	_Inout_ PVOID DeviceObject,
	_Out_ UINT32* CalloutId
)
{
	NTSTATUS Status = STATUS_SUCCESS;
	FWPM_FILTER FwpmFilter = { 0 };
	FWPM_FILTER_CONDITION* FwpmFltCondi = NULL;
	FWPM_CALLOUT FwpmCallout = { 0 };
	FWPM_DISPLAY_DATA FwpmDispData = { 0 };
	BOOL bCalloutReg = FALSE;
	FWPS_CALLOUT FwpsCallout = { 0 };
	FWP_RANGE0* PortRange = NULL;
	PPORT_RANGE pPortRange;
	INT i = 0;
	FwpsCallout.calloutKey = *CalloutKey;
	//FwpsCallout.classifyFn = ;
	//FwpsCallout.notifyFn = ;

	__try {

		Status = FwpsCalloutRegister(DeviceObject, &FwpsCallout, CalloutId);
		if (!NT_SUCCESS(Status)) {

			__leave;
		}

		bCalloutReg = TRUE;
		FwpmDispData.name = L"PsNe ALE Flow Established Callout";
		FwpmDispData.description = L"Callout that gets the process path from a TCP stream";

		FwpmCallout.calloutKey = *CalloutKey;
		FwpmCallout.displayData = FwpmDispData;
		FwpmCallout.applicableLayer = *LayerKey;

		Status = FwpmCalloutAdd(g_EngineHandle, &FwpmCallout, NULL, NULL);
		if (!NT_SUCCESS(Status)) {

			__leave;
		}

		FwpmFltCondi = MyAllocNonPagedPool(NonPagedPool, sizeof(FWPM_FILTER_CONDITION), &g_NonPagedPoolCnt);
		if (FwpmFltCondi == NULL) {

			__leave;
		}

		memset(FwpmFltCondi, 0, sizeof(FWPM_FILTER_CONDITION));

		PortRange = MyAllocNonPagedPool(sizeof(FWP_RANGE0), &g_NonPagedPoolCnt);
		if (PortRange == NULL) {

			__leave;
		}

		memset(PortRange, 0, sizeof(FWP_RANGE0));

		FwpmFilter.layerKey = *LayerKey;
		//FwpmFilter.displayData.name = ;
		FwpmFilter.displayData.description = L"Filter that gets the process path from a TCP stream";

		FwpmFilter.action.type = FWP_ACTION_CALLOUT_INSPECTION;
		FwpmFilter.action.calloutKey = *CalloutKey;
		FwpmFilter.filterCondition = FwpmFltCondi;
		FwpmFilter.numFilterConditions = 1;
		FwpmFilter.subLayerKey = FWPM_SUBLAYER_UNIVERSAL;
		FwpmFilter.weight.type = FWP_EMPTY; // auto-weight.
/*
		for (pPortRange = g_FirstPort; pPortRange; pPortRange = pPortRange->NextPortRange) {

			PortRange[i].valueHigh.type = FWP_UINT16;
			PortRange[i].valueHigh.uint16 = (UINT16)pPortRange->PortTo;
			PortRange[i].valueLow.type = FWP_UINT16;
			PortRange[i].valueLow.uint16 = (UINT16)pPortRange->PortFrom;

			if (PortRange[i].valueHigh.uint16 == 0) {
				PortRange[i].valueHigh.uint16 = (UINT16)pPortRange->PortFrom;
			}

			FwpmFltCondi[i].matchType = FWP_MATCH_RANGE;
			FwpmFltCondi[i].conditionValue.type = FWP_RANGE_TYPE;
			FwpmFltCondi[i].fieldKey = FWPM_CONDITION_IP_REMOTE_PORT; //FWPM_CONDITION_IP_REMOTE_ADDRESS
			FwpmFltCondi[i].conditionValue.rangeValue = &PortRange[i];

			i++;
		}
*/
		Status = FwpmFilterAdd(g_EngineHandle, &FwpmFilter, NULL, NULL);
		if (!NT_SUCCESS(Status)) {

			DbgPrint("[TEST] Status=0x%X", Status);
			__leave;
		}
	}
	__finally {

		if (!NT_SUCCESS(Status)) {

			if (bCalloutReg) {

				FwpsCalloutUnregisterById(*CalloutId);
			}
		}

		if (FwpmFltCondi) {

			MyFreeNonPagedPool(FwpmFltCondi, &g_NonPagedPoolCnt);
		}

		if (PortRange) {

			MyFreeNonPagedPool(PortRange, &g_NonPagedPoolCnt);
		}
	}

	return Status;
}

NTSTATUS MiniWpfRegCallOut(
	_Inout_ PVOID DeviceObject
)
{
	NTSTATUS Status = STATUS_SUCCESS;
	BOOL EngineOpened = FALSE;
	BOOL InTransaction = FALSE;
	FWPM_SESSION FwpmSession = { 0 };
	FwpmSession.flags = FWPM_SESSION_FLAG_DYNAMIC;

	__try {

		Status = FwpmEngineOpen(NULL, RPC_C_AUTHN_WINNT, NULL, &FwpmSession, &g_EngineHandle);
		if (!NT_SUCCESS(Status)) {

			__leave;
		}
		EngineOpened = TRUE;
		Status = FwpmTransactionBegin(g_EngineHandle, 0);
		if (!NT_SUCCESS(Status)) {

			__leave;
		}

		InTransaction = TRUE;
		Status = FwpmTransactionCommit(g_EngineHandle);
		if (!NT_SUCCESS(Status)) {

			__leave;
		}

		InTransaction = FALSE;
	}
	__finally {

		if (!NT_SUCCESS(Status)) {

			if (InTransaction) {

				NTSTATUS AbortStatus;
				AbortStatus = FwpmTransactionAbort(g_EngineHandle);
				_Analysis_assume_(NT_SUCCESS(AbortStatus));
			}

			if (EngineOpened) {

				FwpmEngineClose(g_EngineHandle);
				g_EngineHandle = NULL;
			}
		}
	}

	return Status;
}

void MiniWpfUnRegCallOut()
{
	FwpmEngineClose(g_EngineHandle);
	g_EngineHandle = NULL;
}

_Function_class_(DRIVER_INITIALIZE)
_IRQL_requires_same_
NTSTATUS DriverEntry(
	_In_ PDRIVER_OBJECT DriverObject,
	_In_ PUNICODE_STRING RegistryPath
)
{
	NTSTATUS Status;
	WDFDEVICE WDFDevice;
	WDFDRIVER WDFDriver;
	WDFKEY ConfigKey;
	// Request NX Non-Paged Pool when available
	ExInitializeDriverRuntime(DrvRtPoolNxOptIn);

	__try {
		Status = MiniWpfInitDriverObjects(DriverObject, RegistryPath, &WDFDriver, &WDFDevice);
		if (!NT_SUCCESS(Status)) __leave;

	}
	__finally {}


	return Status;
}

_Function_class_(EVT_WDF_DRIVER_UNLOAD)
_IRQL_requires_same_
_IRQL_requires_max_(PASSIVE_LEVEL)
VOID MiniWpfDriverUnload(
	_In_ WDFDRIVER DriverObject
)
{
	UNREFERENCED_PARAMETER(DriverObject);

	DbgPrint("[MiniWPF] Unload Success");
}