#include "StdAfx.h"

#define INITGUID
#include <guiddef.h>

// Callout driver keys
// {C1C71375-96F3-4391-BA8D-30BD8FA014BF}
DEFINE_GUID(MINI_WPF_STREAM_DATA_V4,
	0xc1c71375, 0x96f3, 0x4391, 0xba, 0x8d, 0x30, 0xbd, 0x8f, 0xa0, 0x14, 0xbf);

// {FF5F83EE-127B-43ED-943C-FF6DC339314B}
DEFINE_GUID(MINI_WPF_STREAM_DATA_V6,
	0xff5f83ee, 0x127b, 0x43ed, 0x94, 0x3c, 0xff, 0x6d, 0xc3, 0x39, 0x31, 0x4b);

// {335B5544-3E15-488F-A4BB-8EC7C47B5842}
DEFINE_GUID(MINI_WPF_ALE_FLOW_ESTABLISHED_V4,
	0x335b5544, 0x3e15, 0x488f, 0xa4, 0xbb, 0x8e, 0xc7, 0xc4, 0x7b, 0x58, 0x42);

// {FA5654AA-55A4-4AC6-B8D1-8A039DD160AD}
DEFINE_GUID(MINI_WPF_ALE_FLOW_ESTABLISHED_V6,
	0xfa5654aa, 0x55a4, 0x4ac6, 0xb8, 0xd1, 0x8a, 0x3, 0x9d, 0xd1, 0x60, 0xad);


DRIVER_INITIALIZE DriverEntry;
EVT_WDF_DRIVER_UNLOAD MiniWpfDriverUnload;

NTSTATUS MiniWPFDataStreamNotify(
	FWPS_CALLOUT_NOTIFY_TYPE NotifyType,
	const GUID* FilterKey,
	const FWPS_FILTER* Filter
)
{
	UNREFERENCED_PARAMETER(NotifyType);
	UNREFERENCED_PARAMETER(FilterKey);
	UNREFERENCED_PARAMETER(Filter);

	return STATUS_SUCCESS;
}

VOID MiniWpfDataStreamDelete(
	UINT16 LayerId,
	UINT32 CalloutId,
	UINT64 FlowContext
)
{
	UNREFERENCED_PARAMETER(LayerId);
	UNREFERENCED_PARAMETER(CalloutId);

	if (FlowContext != 0) {

		// Free the memory for the flow context structure
	}
}

NTSTATUS MiniWpfAleFlowEstablishedNotify(
	FWPS_CALLOUT_NOTIFY_TYPE NotifyType,
	const GUID* FilterKey,
	const FWPS_FILTER* Filter
)
{
	UNREFERENCED_PARAMETER(NotifyType);
	UNREFERENCED_PARAMETER(FilterKey);
	UNREFERENCED_PARAMETER(Filter);

	return STATUS_SUCCESS;
}

void MiniWpfDataStreamUnregCallout()
{
	//FwpmEngineClose(EngineHandle);

	//FwpsCalloutUnregisterById(StreamIdV4);
}


NTSTATUS MiniWpfInitDriverObjects(
	_Inout_ PDRIVER_OBJECT DriverObject,
	const PUNICODE_STRING RegistryPath,
	_Out_ WDFDRIVER* pWDFDriver,
	_Out_ WDFDEVICE* pWDFDevice
)
{
	NTSTATUS Status;
	WDF_DRIVER_CONFIG WDFConfig;
	PWDFDEVICE_INIT WDFDevInit = NULL;

	WDF_DRIVER_CONFIG_INIT(&WDFConfig, WDF_NO_EVENT_CALLBACK);

	WDFConfig.DriverInitFlags |= WdfDriverInitNonPnpDriver;
	WDFConfig.EvtDriverUnload = MiniWpfDriverUnload;

	__try {
		Status = WdfDriverCreate(DriverObject, RegistryPath, WDF_NO_OBJECT_ATTRIBUTES, &WDFConfig, pWDFDriver);

		if (!NT_SUCCESS(Status))
		{
			__leave;
		}

		WDFDevInit = WdfControlDeviceInitAllocate(*pWDFDriver, &SDDL_DEVOBJ_KERNEL_ONLY);

		if (!WDFDevInit)
		{
			Status = STATUS_INSUFFICIENT_RESOURCES;
			__leave;
		}

		WdfDeviceInitSetCharacteristics(WDFDevInit, FILE_AUTOGENERATED_DEVICE_NAME, TRUE);
		WdfDeviceInitSetDeviceType(WDFDevInit, FILE_DEVICE_NETWORK);
		WdfDeviceInitSetCharacteristics(WDFDevInit, FILE_DEVICE_SECURE_OPEN, TRUE);
		Status = WdfDeviceCreate(&WDFDevInit, WDF_NO_OBJECT_ATTRIBUTES, pWDFDevice);

		if (!NT_SUCCESS(Status))
		{
			WdfDeviceInitFree(WDFDevInit);
			__leave;
		}

		WdfControlFinishInitializing(*pWDFDevice);
	}
	__finally {}

	return Status;
}

_Function_class_(DRIVER_INITIALIZE)
_IRQL_requires_same_
NTSTATUS DriverEntry(
	_In_ PDRIVER_OBJECT DriverObject,
	_In_ PUNICODE_STRING RegistryPath
)
{
	NTSTATUS Status;
	WDFDEVICE WDFDevice;
	WDFDRIVER WDFDriver;
	WDFKEY ConfigKey;
	// Request NX Non-Paged Pool when available
	ExInitializeDriverRuntime(DrvRtPoolNxOptIn);

	__try {
		Status = MiniWpfInitDriverObjects(DriverObject, RegistryPath, &WDFDriver, &WDFDevice);
		if (!NT_SUCCESS(Status)) __leave;

	}
	__finally {}


	return Status;
}

_Function_class_(EVT_WDF_DRIVER_UNLOAD)
_IRQL_requires_same_
_IRQL_requires_max_(PASSIVE_LEVEL)
VOID MiniWpfDriverUnload(
	_In_ WDFDRIVER DriverObject
)
{
	UNREFERENCED_PARAMETER(DriverObject);

	DbgPrint("[MiniWPF] Unload Success");
}