# 현재 실행된 프로세스의 부모 프로세스 전체 경로 획득하는 방법

기존에는 현재 실행 된 프로세스의 전체 경로를 획득하는 방법에 대해서 알았다면  
이번에는 현재 실행 된 프로세스의 부모 프로세스의 전체 경로를 획득하는 방법에  
대해서 기술해 보도록 하겠습니다.  

이 기술은 기존에 부모 프로세스의 PID를 획득하는 방법부터 시작을 해야 합니다.  
여기서는 부모 프로세스의 PID를 획득했다는 가정하에 작성을 해보도록 하겠습니다.  

먼저 부모 프로세스의 PID를 획득 한 다음에 부모 프로세스의 EPROCESS 포인터를 받아야 합니다.  
그러기 위해서 사용하는 API는 바로 PsLookupProcessByProcessId API 입니다.  
그리고 PsLookupProcessByProcessId API를 호출 하여 사용 한 뒤에는  
반드시 ObDereferenceObject API를 호출하여 참조 카운트를 감소 시켜줘야 합니다.  

```c
NTSTATUS PsLookupProcessByProcessId(
  HANDLE    ProcessId,
  PEPROCESS *Process
);

void ObDereferenceObject(
   a
);
```

이렇게 PsLookupProcessByProcessId API를 호출하여 부모 프로세스의 EPROCESS 포인터를 획득합니다.  
그리고 난 다음에 부모 프로세스에 현재 스레드를 Attach를 해줘야 합니다.  
그러기 위해서 호출 되는 API는 바로 KeStackAttachProcess API 입니다.   
이 후 기존에 PEB에 접근하는 방식으로 EPROCESS 포인터를 조작하여  
프로세스의 ImagePath를 획득 하면 됩니다.  
그리고 나중에는 KeUnstackDetachProcess API를 호출하여  
마찬가지로 부모 프로세스로부터 현재 스레드를 Detach를 해줘야 합니다.  

```c
void KeStackAttachProcess(
  PRKPROCESS   PROCESS,
  PRKAPC_STATE ApcState
);

void KeUnstackDetachProcess(
  PRKAPC_STATE ApcState
);
```

그러면 이제 위 순서를 소스코드로 한번 보도록 하겠습니다.  

```c
ULONG ProcessGetParentPath(ULONG ProcessId, PWCHAR ParentPathW)
{
	NTSTATUS Status;
	PEPROCESS pProcess = NULL;
	ULONG ParentPId = ProcessGetParentPId(ProcessId); # 부모 프로세스 PID 획득

	if (ParentPId == 0) return 0;

	Status = PsLookupProcessByProcessId(UlongToPtr(ParentPId), &pProcess);
	if (Status == STATUS_SUCCESS && pProcess != NULL) {
		KAPC_STATE APCState;

		KeStackAttachProcess((PRKPROCESS)pProcess, &APCState);
		GetProcessFullPath(pProcess, ParentPathW); # PEB에 접근하여 IamgePath 획득
		KeUnstackDetachProcess(&APCState);
		ObDereferenceObject(pProcess);
	}

	return ParentPId;
}
```

이렇게 호출하여 사용하면 현재 실행된 프로세스의 부모 프로세스의 경로를 획득 할 수 있습니다.

