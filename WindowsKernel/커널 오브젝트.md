# 커널 오브젝트(Kernel Object)

프로세스, 스레드 그리고 파일과 같은 리소스(resource)들을 원활히 관리하기 위해 필요한 정보를 저장해야 합니다.    
이 때 데이터를 저장하는 메모리 블록을 커널 오브젝트라고 합니다.   
커널 오브젝트는 가능한 일관되게 유지될 수 있도록 하기 위해서    
커널에서만 접근할 수 있도록 의도적으로 제약 사항을 만들어 놓았습니다.   
그래서 애플리케이션에서는 커널 오브젝트에 직접적으로 접근이 불가능하며, 데이터 수정 또한 불가능합니다.   
따라서 커널 오브젝트는 운영체제에 종속적이며, 생성과 소멸 또한 운영체제에 의해 결정 됩니다.   
그리고 사용자가 리소스 생성을 요청 했을 때 운영체제는 사용자가 요청한 대로 리소스를 생성하는데   
예를 들어 프로세스가 생성 될 때마다  프로세스 관리 구조체(PCB)가 하나씩 생성되고,   
새로 생성된 프로세스 정보들로 초기화를 하는데 이것을 커널 오브젝트 라고 합니다.   

그리고 리소스 생성을 요청한 사용자에게 운영체제가 생성한 커널 오브젝트를 구분하기 위한 핸들 값을 반환 합니다.   
윈도우 상에서 핸들 값은 리소스별로 독립적으로 유지 됩니다. (즉 핸들은 유니크한 녀석입니다.)   
만약 어떤 스레드가 다른 프로세스의 스레드에게 자신의 핸들 값을 전달 했을 경우,   
전달 받은 핸들 값을 이용하여 수행하는 동작은 실패할 수도 있고, 혹은 더 좋지 않은 결과를 가져올 수도 있습니다.   
왜냐하면 각 프로세스별로 독립된 프로세스 핸들 테이블이 존재하고 동일한 핸들 값이라고   
전혀 다른 커널 오브젝트를 참조할 수 있기 때문입니다.   

그리고 커널 오브젝트에 생성 소멸을 운영체제가 담당한다고 하였는데, 커널 오브젝트가 생성 되면   
참조하는 대상을 관리하기 위해 사용 카운트(Usage Count)로 관리를 합니다.   
보통 우리가 바탕화면에서 A 라는 프로세스를 실행했다고 가정했을 때   
사용 카운트(Usage Count)는 1이라고 생각할 수 있습니다.  

그리고 커널 오브젝트에 생성 소멸을 운영체제가 담당한다고 하였는데, 커널 오브젝트가 생성 되면   
참조하는 대상을 관리하기 위해 사용 카운트(Usage Count)로 관리를 합니다.   
보통 우리가 바탕화면에서 A 라는 프로세스를 실행했다고 가정했을 때   
사용 카운트(Usage Count)는 1이라고 생각할 수 있습니다.   
하지만 바탕화면은 explorer 프로세스이고, explorer 이녀석은 부모 프로세스가 됩니다.   
즉 explorer 프로세스를 통해서 A.exe 프로세스가 실행되었기에 explorer 프로세스는    
A 프로세스의 커널 오브젝트의 핸들을 획득하게 되면서 커널 오브젝트의 사용 카운트(Usage Count)는 2가 됩니다.   
즉 A 프로세스와 부모 프로세스인 explorer 프로세스가 A 프로세스의 커널 오브젝트를 참조하게 됩니다.   
(그 이유는 CreateProcess API 를 확인하면 이유를 알 수 있으니 찾아보시면 되겠습니다.)   
그리고 A 프로세스가 종료 되면 사용 카운트(Usage Count)의 값은 1이 감소하게 됩니다.   
그리고 어떠한 프로세스도 A 프로세스의 커널 오브젝트를 참조하지 않게 되면(Usage Count 가 0이 되었을 경우)   
운영체제는 해당 커널 오브젝트를 제거 합니다.  
